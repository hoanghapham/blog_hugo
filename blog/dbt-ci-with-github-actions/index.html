<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>How to run dbt CI with GitHub Action | Ha&#39;s Learning Docs</title>
<meta name="keywords" content="" />
<meta name="description" content="If you are familiar with the modern data stack, probably dbt is no stranger. dbt tries to bring the best practices from the software engineering world into data development, and one of such practices is the idea of automated testing and continuous integration (CI).
While dbt Cloud provides a &ldquo;slim CI&rdquo; feature that satisfies most basic needs, you will have more control over your CI jobs if you make use of your git provider&rsquo;s CI/CD functions.">
<meta name="author" content="">
<link rel="canonical" href="http://hoanghapham.github.io/blog/dbt-ci-with-github-actions/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.6f60056d44d3f7eb69a4bc6c332b59960f3a995802bded244750232f33713c49.css" integrity="sha256-b2AFbUTT9&#43;tppLxsMytZlg86mVgCve0kR1AjLzNxPEk=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js" integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5&#43;kdJvBz5iKbt6B5PJI="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="http://hoanghapham.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://hoanghapham.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://hoanghapham.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://hoanghapham.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="http://hoanghapham.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.89.2" />
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="How to run dbt CI with GitHub Action" />
<meta property="og:description" content="If you are familiar with the modern data stack, probably dbt is no stranger. dbt tries to bring the best practices from the software engineering world into data development, and one of such practices is the idea of automated testing and continuous integration (CI).
While dbt Cloud provides a &ldquo;slim CI&rdquo; feature that satisfies most basic needs, you will have more control over your CI jobs if you make use of your git provider&rsquo;s CI/CD functions." />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://hoanghapham.github.io/blog/dbt-ci-with-github-actions/" /><meta property="article:section" content="blog" />
<meta property="article:published_time" content="2021-11-13T12:39:24&#43;07:00" />
<meta property="article:modified_time" content="2021-11-13T12:39:24&#43;07:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="How to run dbt CI with GitHub Action"/>
<meta name="twitter:description" content="If you are familiar with the modern data stack, probably dbt is no stranger. dbt tries to bring the best practices from the software engineering world into data development, and one of such practices is the idea of automated testing and continuous integration (CI).
While dbt Cloud provides a &ldquo;slim CI&rdquo; feature that satisfies most basic needs, you will have more control over your CI jobs if you make use of your git provider&rsquo;s CI/CD functions."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Blogs",
      "item": "http://hoanghapham.github.io/blog/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "How to run dbt CI with GitHub Action",
      "item": "http://hoanghapham.github.io/blog/dbt-ci-with-github-actions/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "How to run dbt CI with GitHub Action",
  "name": "How to run dbt CI with GitHub Action",
  "description": "If you are familiar with the modern data stack, probably dbt is no stranger. dbt tries to bring the best practices from the software engineering world into data development, and one of such practices is the idea of automated testing and continuous integration (CI).\nWhile dbt Cloud provides a \u0026ldquo;slim CI\u0026rdquo; feature that satisfies most basic needs, you will have more control over your CI jobs if you make use of your git provider\u0026rsquo;s CI/CD functions.",
  "keywords": [
    
  ],
  "articleBody": "If you are familiar with the modern data stack, probably dbt is no stranger. dbt tries to bring the best practices from the software engineering world into data development, and one of such practices is the idea of automated testing and continuous integration (CI).\nWhile dbt Cloud provides a “slim CI” feature that satisfies most basic needs, you will have more control over your CI jobs if you make use of your git provider’s CI/CD functions. In this project, we will look at how to create a dbt CI job using GitHub Actions\nThe demo project can be found here: https://github.com/hoanghapham/dbt_ci_demo\nWhat is GitHub Action? GitHub Actions is GitHub’s tool to schedule \u0026 execute software development workflows right within your GitHub repository. The workflows are configured using YAML files placing in the .github/workflows folder.\nIf you are not familiar with the tool, it is best to start with GitHub’s documentation first. This tutorial will assume that you have already grasped the basic concepts of GitHub Actions.\nPreparation   Required dbt version: 0.21.0 or above (As of this writing’s date, v0.21.0 is the latest version). dbt 0.21 has introduced the powerful dbt build command that you should definitely use.\n  dbt project setup: dbt stores information about database connections in the profiles.yml file. In this tutorial, we will place the file in a test_profiles folder.\n  Database: In this tutorial, I will use a free Google BigQuery account. You can easily register for one yourself following this instruction. If you decide to use BigQuery, you will also need to create a Service Account, and download the key following this instruction.\n  Actions secrets: Important information like credentials, passwords, access tokens… must not be committed to the repository. Instead, you can set them up as Action secrets.\n  With that out of the way, let’s dive in.\nRun a workflow upon PR creation First, let’s configure a job to run upon a new PR against the main branch.In general, the workflow will need to have the following steps:\n Check out the code branch you have just pushed Read the database credentials from the repository’s secret Install dbt to the GitHub action runner, as well as necessary packages Build \u0026 test dbt models Archive the compiled SQLs for debugging purpose  Suppose that our profiles.yml has a ci target like so:\ndemo_ci: target: ci outputs: ci: type: bigquery method: service-account project: \"{{ env_var('DBT_CI_BIGQUERY_PROJECT_ID') }}\" dataset: dbt_ci keyfile: ./test_profiles/cred.json threads: 4 timeout_seconds: 300 priority: interactive Our basic workflow will look like this:\nname: CI testing - Full run - No container on: [pull_request] # Run this workflow when there is a new PR jobs: ci-full-run-no-container: runs-on: ubuntu-latest env: DBT_PROFILES_DIR: ./test_profiles # Tell dbt to look for profiles in this folder DBT_CI_BIGQUERY_PROJECT_ID: ${{ secrets.DBT_CI_BIGQUERY_PROJECT_ID }} # Make the BigQuery project ID available as an env var steps: - name: Check out ${{ github.head_ref }} uses: actions/checkout@v2 - name: Read Bigquery credentials from repo secret shell: bash env: DBT_CI_BIGQUERY_CRED: ${{ secrets.DBT_CI_BIGQUERY_CRED }} run: |mkdir -p ./test_profiles; echo $DBT_CI_BIGQUERY_CRED | base64 -d -i  ./test_profiles/cred.json # Need to install dbt into the runner - name: Install dbt \u0026 packages shell: bash run: |pip3 install dbt==0.21.0; dbt deps; - name: Build \u0026 test models shell: bash run: dbt build  # Upload compiled SQL as artifacts - name: Archive compiled SQL if: ${{ always() }} uses: actions/upload-artifact@v2 with: name: compiled_sql path: ./target/compiled A few notes:\n  After the job finishes running, the runner will be destroyed. All resources created in the runner (checked-out codes, new files created…) will also be destroyed, unless you upload them as artifacts.\n  In the Read credential step, since I encoded my credentials using base64 before adding it into the secrets, I needed to decode it before putting it into a cred.json file.\n  In the final step (Archive compiled SQL), the if: ${{ always() }} expression ensures this step will always run, even when the previous dbt build step fails (because of a failed test, or an invalid dbt run). This step will make the compiled SQL available to you after the job finished running.\n  After merging this workflow, whenever you make a new PR against your main branch, the workflow will be triggered. The GitHub UI will show you which workflows are running, just like when you enable Slim CI in dbt.\nIncremental testing workflow The problem with the workflow above is that, even when you only modify one model, the whole project will be rebuilt when you invoke dbt build. This can result in an expensive (as in, cost you more BigQuery money) and slow-running workflow.\nTo avoid this, you can use dbt’s state and defer feature to compare your current project with a previous state, and only run the new and modified models.\nThe state of a dbt project is reflected in the manifest.json file. When you run some dbt commands (like compile, run, test…) this file will be generated into the target folder. By default, this folder is ignored and not pushed to GitHub, so we need to make this file available in the action runner.\nThere are a few approaches, each of which has its own pros and cons:\n Manually commit the manifest.json file Generate the manifest.json file at run time Have an automated workflow to generate and commit the manifest.json file  After having the manifest file available, you can change the dbt build step into\ndbt build --select state:modified --defer --state folder-with-manifest-file/ Let’s go into the details of the approaches below.\nManually commit the manifest file You can either:\n  Add !target/manifest.json into the .gitignore file so that everything in the target folder will be ignored except the manifest.json file. This way, every time you run a dbt command and the state of your project changes, you can commit that change.\nThis is also the drawback of this approach, since during model development, it is unnecessary to commit all the tiny changes. In the GitHub Actions workflow, you will also need a step to copy the manifest file to a different location other than the target folder before running a new dbt command.\n  Or, manually copy the manifest.json file to a different location only when necessary. This way you have better control of which state to retain, but of course, you have to remember to do it every time you push something new to your repository.\n  The advantage of this approach is that it is the easiest to do. However, it is quite cumbersome, and is definitely not cool. We are here to do cool stuff, so let’s automate this process.\nAutomatically generate manifest file at run time One way to have the manifest file reflecting the old project state is to generate it directly from your main branch. Here’s the workflow to do so:\nname: CI testing - Incremental run - Checkout master on: [pull_request] jobs: ci-incr-run-checkout-master: runs-on: ubuntu-latest env: DBT_PROFILES_DIR: ./test_profiles DBT_CI_BIGQUERY_PROJECT_ID: ${{ secrets.DBT_CI_BIGQUERY_PROJECT_ID }} steps: - name: Check out ${{ github.head_ref }} uses: actions/checkout@v2 # Check out master branch to a different folder - name: Checkout master uses: actions/checkout@v2 with: ref: master path: master_branch/ # Should also copy the credential into the master_branch folder - name: Read Bigquery credentials from secret shell: bash env: DBT_CI_BIGQUERY_CRED: ${{ secrets.DBT_CI_BIGQUERY_CRED }} run: |mkdir -p ./test_profiles; echo $DBT_CI_BIGQUERY_CRED | base64 -d -i  ./test_profiles/cred.json; echo $DBT_CI_BIGQUERY_CRED | base64 -d -i  ./master_branch/test_profiles/cred.json; - name: Install dbt \u0026 packages shell: bash run: |pip3 install dbt==0.21.0; dbt deps; - name: Generate manifest.json from master shell: bash run: dbt compile --project-dir master_branch/ --profiles-dir master_branch/test_profiles/ # Tell dbt to look up previous manifest file in master_branch/target  - name: Build \u0026 test models shell: bash run: dbt build --select state:modified --defer --state master_branch/target/ - name: Archive compiled SQL if: ${{ always() }} uses: actions/upload-artifact@v2 with: name: compiled_sql path: ./target/compiled How this workflow is different from the previous one:\n First, we check out the files from our master branch to the master_branch folder within the current project Then, we generate the manifest file from the master branch by running dbt compile, while specifying the project directory as master_branch/. The manifest file will be generated into master_branch/target/ folder. Note that it is necessary to also copy the credential file into the master_branch folder. Finally, run dbt build while pointing to the master_branch/target/ folder for state comparison  As you can see, in the incremental workflow, only the new test_model.sql file is run, while the original full run workflow will run all the files.\nSo we have started to automate the boring stuff! However, this workflow has a drawback. Every time you push something new to an opened PR, the whole checkout and generate manifest steps will have to run again.\nThis may be OK if your project is small, but it may cost you more job run time if your project has hundreds of models.\nWe can certainly flex further and look for a way to reuse this manifest file.\nGenerate manifest file when merging to main branch During model development, it is unlikely that the manifest file will change that much. We would want to reuse this manifest file, but GitHub Actions does not allow sharing files between different job runs.\nWe can work around this with workflow that update the manifest file when you merge a new PR. This is the workflow that do so:\nname: Update dbt project state on: pull_request: types: [closed] workflow_dispatch: jobs: update-project-state: if: github.event.pull_request.merged == true runs-on: ubuntu-latest env: DBT_PROFILES_DIR: ./test_profiles DBT_CI_BIGQUERY_PROJECT_ID: ${{ secrets.DBT_CI_BIGQUERY_PROJECT_ID }} steps: - name: Checkout master uses: actions/checkout@v2 with: ref: master - name: Read Bigquery credentials from secret shell: bash env: DBT_CI_BIGQUERY_CRED: ${{ secrets.DBT_CI_BIGQUERY_CRED }} run: |mkdir -p ./test_profiles; echo $DBT_CI_BIGQUERY_CRED | base64 -d -i  ./test_profiles/cred.json; - name: Install dbt \u0026 packages shell: bash run: |pip3 install dbt==0.21.0; dbt deps; - name: Generate manifest.json from master shell: bash run: |dbt deps; dbt compile --no-version-check; mkdir -p ./current_state; cp ./target/manifest.json ./current_state/manifest.json; - name: Commit new manifest.json file uses: EndBug/add-and-commit@v7.4.0 with: add: './current_state/manifest.json' message: 'manifest.json updated' push: true branch: master This part:\non: pull_request: types: [closed] workflow_dispatch: jobs: update-project-state: if: github.event.pull_request.merged == true runs-on: ubuntu-latest specifies the types of events that will trigger this workflow.\n  pull_request: This workflow will run when you merge a PR to the master branch (defined with the if expression).\n  workflow_dispatch: This means that you can also manually trigger this workflow from GitHub Action’s UI.\n  After this, in the main CI workflow you can remove the “Checkout master” and “Generate manifest file from master” steps. Since we now have the manifest.json file in the current_state folder, when running dbt build you need to point to this folder for state comparison.\ndbt build --select state:modified --defer --state current_state/ Bonus: Run jobs inside a container In the workflows above, we have a step to install dbt into the runner:\npip3 install dbt==0.21.0 You can also run dbt using dbt Labs' official Docker image so you won’t need to worry about dependencies. Simply add the container and image properties to the job config:\njobs: ci-incr-run: runs-on: ubuntu-latest container: image: fishtownanalytics/dbt:0.21.0 Now you can remove the pip3 install dbt==0.21.0\nConclusion Hope that this demonstration can help others who are trying to improve their dbt workflow. If you have any comments or questions, please create an issue in this repo: https://github.com/hoanghapham/dbt_ci_demo.\n",
  "wordCount" : "1864",
  "inLanguage": "en",
  "datePublished": "2021-11-13T12:39:24+07:00",
  "dateModified": "2021-11-13T12:39:24+07:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "http://hoanghapham.github.io/blog/dbt-ci-with-github-actions/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Ha's Learning Docs",
    "logo": {
      "@type": "ImageObject",
      "url": "http://hoanghapham.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://hoanghapham.github.io/" accesskey="h" title="Ha&#39;s Learning Docs (Alt + H)">Ha&#39;s Learning Docs</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      How to run dbt CI with GitHub Action
    </h1>
    <div class="post-meta"><span title='2021-11-13 12:39:24 +0700 +07'>November 13, 2021</span>

</div>
  </header> <div class="toc">
    <details  open>
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#what-is-github-action" aria-label="What is GitHub Action?">What is GitHub Action?</a></li>
                <li>
                    <a href="#preparation" aria-label="Preparation">Preparation</a></li>
                <li>
                    <a href="#run-a-workflow-upon-pr-creation" aria-label="Run a workflow upon PR creation">Run a workflow upon PR creation</a></li>
                <li>
                    <a href="#incremental-testing-workflow" aria-label="Incremental testing workflow">Incremental testing workflow</a><ul>
                        
                <li>
                    <a href="#manually-commit-the-manifest-file" aria-label="Manually commit the manifest file">Manually commit the manifest file</a></li>
                <li>
                    <a href="#automatically-generate-manifest-file-at-run-time" aria-label="Automatically generate manifest file at run time">Automatically generate manifest file at run time</a></li>
                <li>
                    <a href="#generate-manifest-file-when-merging-to-main-branch" aria-label="Generate manifest file when merging to main branch">Generate manifest file when merging to main branch</a></li></ul>
                </li>
                <li>
                    <a href="#bonus-run-jobs-inside-a-container" aria-label="Bonus: Run jobs inside a container">Bonus: Run jobs inside a container</a></li>
                <li>
                    <a href="#conclusion" aria-label="Conclusion">Conclusion</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><p>If you are familiar with the modern data stack, probably <strong>dbt</strong> is no stranger. dbt tries to bring the best practices from the software engineering world into data development, and one of such practices is the idea of automated testing and continuous integration (CI).</p>
<p>While dbt Cloud provides a &ldquo;slim CI&rdquo; feature that satisfies most basic needs, you will have more control over your CI jobs if you make use of your git provider&rsquo;s CI/CD functions. In this project, we will look at how to create a dbt CI job using GitHub Actions</p>
<p>The demo project can be found here: <a href="https://github.com/hoanghapham/dbt_ci_demo">https://github.com/hoanghapham/dbt_ci_demo</a></p>
<h1 id="what-is-github-action">What is GitHub Action?<a hidden class="anchor" aria-hidden="true" href="#what-is-github-action">#</a></h1>
<p>GitHub Actions is GitHub&rsquo;s tool to schedule &amp; execute software development workflows right within your GitHub repository. The workflows are configured using YAML files placing in the <code>.github/workflows</code> folder.</p>
<p>If you are not familiar with the tool, it is best to start with <a href="https://docs.github.com/en/actions/learn-github-actions/understanding-github-actions">GitHub&rsquo;s documentation</a> first. This tutorial will assume that you have already grasped the basic concepts of GitHub Actions.</p>
<h1 id="preparation">Preparation<a hidden class="anchor" aria-hidden="true" href="#preparation">#</a></h1>
<ul>
<li>
<p><strong>Required dbt version:</strong> 0.21.0 or above (As of this writing&rsquo;s date, v0.21.0 is the latest version). dbt 0.21 has introduced the powerful <code>dbt build</code> command that you should definitely use.</p>
</li>
<li>
<p><strong>dbt project setup</strong>: dbt stores information about database connections in the <code>profiles.yml</code> file. In this tutorial, we will place the file in a <code>test_profiles</code> folder.</p>
</li>
<li>
<p><strong>Database:</strong> In this tutorial, I will use a free Google BigQuery account. You can easily register for one yourself <a href="https://cloud.google.com/bigquery/docs/sandbox">following this instruction</a>.
If you decide to use BigQuery, you will also need to create a Service Account, and download the key <a href="https://cloud.google.com/iam/docs/creating-managing-service-account-keys">following this instruction</a>.</p>
</li>
<li>
<p><strong>Actions secrets:</strong> Important information like credentials, passwords, access tokens&hellip; must not be committed to the repository. Instead, you can set them up as Action secrets.</p>
<p><img loading="lazy" src="/dbt-ci-with-github-actions/secrets.png" alt=""  />
</p>
</li>
</ul>
<p>With that out of the way, let&rsquo;s dive in.</p>
<h1 id="run-a-workflow-upon-pr-creation">Run a workflow upon PR creation<a hidden class="anchor" aria-hidden="true" href="#run-a-workflow-upon-pr-creation">#</a></h1>
<p>First, let&rsquo;s configure a job to run upon a new PR against the main branch.In general, the workflow will need to have the following steps:</p>
<ul>
<li>Check out the code branch you have just pushed</li>
<li>Read the database credentials from the repository&rsquo;s secret</li>
<li>Install dbt to the GitHub action runner, as well as necessary packages</li>
<li>Build &amp; test dbt models</li>
<li>Archive the compiled SQLs for debugging purpose</li>
</ul>
<p>Suppose that our <code>profiles.yml</code> has a <code>ci</code> target like so:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#f92672">demo_ci</span>:
  <span style="color:#f92672">target</span>: <span style="color:#ae81ff">ci</span>

  <span style="color:#f92672">outputs</span>:
    <span style="color:#f92672">ci</span>:
      <span style="color:#f92672">type</span>: <span style="color:#ae81ff">bigquery</span>
      <span style="color:#f92672">method</span>: <span style="color:#ae81ff">service-account</span>
      <span style="color:#f92672">project</span>: <span style="color:#e6db74">&#34;{{ env_var(&#39;DBT_CI_BIGQUERY_PROJECT_ID&#39;) }}&#34;</span>
      <span style="color:#f92672">dataset</span>: <span style="color:#ae81ff">dbt_ci</span>
      <span style="color:#f92672">keyfile</span>: <span style="color:#ae81ff">./test_profiles/cred.json</span>
      <span style="color:#f92672">threads</span>: <span style="color:#ae81ff">4</span>
      <span style="color:#f92672">timeout_seconds</span>: <span style="color:#ae81ff">300</span>
      <span style="color:#f92672">priority</span>: <span style="color:#ae81ff">interactive</span>
</code></pre></div><p>Our basic workflow will look like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#f92672">name</span>: <span style="color:#ae81ff">CI testing - Full run - No container</span>
<span style="color:#f92672">on</span>: [<span style="color:#ae81ff">pull_request]</span> <span style="color:#75715e"># Run this workflow when there is a new PR</span>

<span style="color:#f92672">jobs</span>:
  <span style="color:#f92672">ci-full-run-no-container</span>:
    <span style="color:#f92672">runs-on</span>: <span style="color:#ae81ff">ubuntu-latest</span>

    <span style="color:#f92672">env</span>: 
      <span style="color:#f92672">DBT_PROFILES_DIR</span>: <span style="color:#ae81ff">./test_profiles</span> <span style="color:#75715e"># Tell dbt to look for profiles in this folder</span>
      <span style="color:#f92672">DBT_CI_BIGQUERY_PROJECT_ID</span>: <span style="color:#ae81ff">${{ secrets.DBT_CI_BIGQUERY_PROJECT_ID }}</span> <span style="color:#75715e"># Make the BigQuery project ID available as an env var</span>

    <span style="color:#f92672">steps</span>:

      - <span style="color:#f92672">name</span>: <span style="color:#ae81ff">Check out ${{ github.head_ref }}</span>
        <span style="color:#f92672">uses</span>: <span style="color:#ae81ff">actions/checkout@v2</span>
		
      - <span style="color:#f92672">name</span>: <span style="color:#ae81ff">Read Bigquery credentials from repo secret</span>
        <span style="color:#f92672">shell</span>: <span style="color:#ae81ff">bash</span>
        <span style="color:#f92672">env</span>: 
          <span style="color:#f92672">DBT_CI_BIGQUERY_CRED</span>: <span style="color:#ae81ff">${{ secrets.DBT_CI_BIGQUERY_CRED }}</span>
        <span style="color:#f92672">run</span>: |<span style="color:#e6db74">
</span><span style="color:#e6db74">          mkdir -p ./test_profiles;
</span><span style="color:#e6db74">          echo $DBT_CI_BIGQUERY_CRED | base64 -d -i &gt; ./test_profiles/cred.json</span>          

      <span style="color:#75715e"># Need to install dbt into the runner</span>
      - <span style="color:#f92672">name</span>: <span style="color:#ae81ff">Install dbt &amp; packages</span>
        <span style="color:#f92672">shell</span>: <span style="color:#ae81ff">bash</span>
        <span style="color:#f92672">run</span>: |<span style="color:#e6db74">
</span><span style="color:#e6db74">          pip3 install dbt==0.21.0;
</span><span style="color:#e6db74">          dbt deps;</span>          

      - <span style="color:#f92672">name</span>: <span style="color:#ae81ff">Build &amp; test models</span>
        <span style="color:#f92672">shell</span>: <span style="color:#ae81ff">bash</span>
        <span style="color:#f92672">run</span>: <span style="color:#ae81ff">dbt build </span>
		
      <span style="color:#75715e"># Upload compiled SQL as artifacts</span>
      - <span style="color:#f92672">name</span>: <span style="color:#ae81ff">Archive compiled SQL</span>
        <span style="color:#f92672">if</span>: <span style="color:#ae81ff">${{ always() }}</span>
        <span style="color:#f92672">uses</span>: <span style="color:#ae81ff">actions/upload-artifact@v2</span>
        <span style="color:#f92672">with</span>: 
          <span style="color:#f92672">name</span>: <span style="color:#ae81ff">compiled_sql</span>
          <span style="color:#f92672">path</span>: <span style="color:#ae81ff">./target/compiled</span>
</code></pre></div><p>A few notes:</p>
<ul>
<li>
<p>After the job finishes running, the runner will be destroyed. All resources created in the runner (checked-out codes, new files created&hellip;) will also be destroyed, unless you upload them as <strong>artifacts</strong>.</p>
</li>
<li>
<p>In the <strong>Read credential</strong> step, since I encoded my credentials using <code>base64</code> before adding it into the secrets, I needed to decode it before putting it into a <code>cred.json</code> file.</p>
</li>
<li>
<p>In the final step (<strong>Archive compiled SQL</strong>), the <code>if: ${{ always() }}</code> expression ensures this step will always run, even when the previous <code>dbt build</code> step fails (because of a failed test, or an invalid dbt run). This step will make the compiled SQL available to you after the job finished running.</p>
</li>
</ul>
<p>After merging this workflow, whenever you make a new PR against your main branch, the workflow will be triggered. The GitHub UI will show you which workflows are running, just like when you enable Slim CI in dbt.</p>
<p><img loading="lazy" src="/dbt-ci-with-github-actions/pr_testing.png" alt=""  />

<img loading="lazy" src="/dbt-ci-with-github-actions/pr_passed.png" alt=""  />
</p>
<h1 id="incremental-testing-workflow">Incremental testing workflow<a hidden class="anchor" aria-hidden="true" href="#incremental-testing-workflow">#</a></h1>
<p>The problem with the workflow above is that, even when you only modify one model, <strong>the whole project</strong> will be rebuilt when you invoke <code>dbt build</code>. This can result in an expensive (as in, cost you more BigQuery money) and slow-running workflow.</p>
<p>To avoid this, you can use dbt&rsquo;s <strong>state</strong> and <strong>defer</strong> feature to compare your current project with a previous state, and only run the new and modified models.</p>
<p>The state of a dbt project is reflected in the <code>manifest.json</code> file. When you run some dbt commands (like <code>compile</code>, <code>run</code>, <code>test</code>&hellip;) this file will be generated into the <code>target</code> folder. By default, this folder is ignored and not pushed to GitHub, so we need to make this file available in the action runner.</p>
<p><img loading="lazy" src="/dbt-ci-with-github-actions/manifest_location.png" alt=""  />
</p>
<p>There are a few approaches, each of which has its own pros and cons:</p>
<ul>
<li>Manually commit the <code>manifest.json</code> file</li>
<li>Generate the <code>manifest.json</code> file at run time</li>
<li>Have an automated workflow to generate and commit the <code>manifest.json</code> file</li>
</ul>
<p>After having the manifest file available, you can change the <code>dbt build</code> step into</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">dbt build --select state:modified --defer --state folder-with-manifest-file/
</code></pre></div><p>Let&rsquo;s go into the details of the approaches below.</p>
<h2 id="manually-commit-the-manifest-file">Manually commit the manifest file<a hidden class="anchor" aria-hidden="true" href="#manually-commit-the-manifest-file">#</a></h2>
<p>You can either:</p>
<ul>
<li>
<p>Add <code>!target/manifest.json</code> into the <code>.gitignore</code> file so that everything in the <code>target</code> folder will be ignored except the <code>manifest.json</code> file. This way, every time you run a dbt command and the state of your project changes, you can commit that change.</p>
<p>This is also the drawback of this approach, since during model development, it is unnecessary to commit all the tiny changes. In the GitHub Actions workflow, you will also need a step to copy the manifest file to a different location other than the <code>target</code> folder before running a new dbt command.</p>
</li>
<li>
<p>Or, manually copy the <code>manifest.json</code> file to a different location only when necessary. This way you have better control of which state to retain, but of course, you have to <strong>remember</strong> to do it every time you push something new to your repository.</p>
</li>
</ul>
<p>The advantage of this approach is that it is the easiest to do. However, it is quite cumbersome, and is definitely <strong>not cool</strong>. We are here to do cool stuff, so let&rsquo;s automate this process.</p>
<h2 id="automatically-generate-manifest-file-at-run-time">Automatically generate manifest file at run time<a hidden class="anchor" aria-hidden="true" href="#automatically-generate-manifest-file-at-run-time">#</a></h2>
<p>One way to have the manifest file reflecting the old project state is to generate it directly from your main branch. Here&rsquo;s the workflow to do so:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#f92672">name</span>: <span style="color:#ae81ff">CI testing - Incremental run - Checkout master</span>
<span style="color:#f92672">on</span>: [<span style="color:#ae81ff">pull_request]</span>

<span style="color:#f92672">jobs</span>:
  <span style="color:#f92672">ci-incr-run-checkout-master</span>:
    <span style="color:#f92672">runs-on</span>: <span style="color:#ae81ff">ubuntu-latest</span>

    <span style="color:#f92672">env</span>: 
      <span style="color:#f92672">DBT_PROFILES_DIR</span>: <span style="color:#ae81ff">./test_profiles</span>
      <span style="color:#f92672">DBT_CI_BIGQUERY_PROJECT_ID</span>: <span style="color:#ae81ff">${{ secrets.DBT_CI_BIGQUERY_PROJECT_ID }}</span>

    <span style="color:#f92672">steps</span>:

      - <span style="color:#f92672">name</span>: <span style="color:#ae81ff">Check out ${{ github.head_ref }}</span>
        <span style="color:#f92672">uses</span>: <span style="color:#ae81ff">actions/checkout@v2</span>

      <span style="color:#75715e"># Check out master branch to a different folder</span>
      - <span style="color:#f92672">name</span>: <span style="color:#ae81ff">Checkout master</span>
        <span style="color:#f92672">uses</span>: <span style="color:#ae81ff">actions/checkout@v2</span>
        <span style="color:#f92672">with</span>:
          <span style="color:#f92672">ref</span>: <span style="color:#ae81ff">master</span>
          <span style="color:#f92672">path</span>: <span style="color:#ae81ff">master_branch/</span>

      <span style="color:#75715e"># Should also copy the credential into the master_branch folder</span>
      - <span style="color:#f92672">name</span>: <span style="color:#ae81ff">Read Bigquery credentials from secret</span>
        <span style="color:#f92672">shell</span>: <span style="color:#ae81ff">bash</span>
        <span style="color:#f92672">env</span>: 
          <span style="color:#f92672">DBT_CI_BIGQUERY_CRED</span>: <span style="color:#ae81ff">${{ secrets.DBT_CI_BIGQUERY_CRED }}</span>
        <span style="color:#f92672">run</span>: |<span style="color:#e6db74">
</span><span style="color:#e6db74">          mkdir -p ./test_profiles;
</span><span style="color:#e6db74">          echo $DBT_CI_BIGQUERY_CRED | base64 -d -i &gt; ./test_profiles/cred.json;
</span><span style="color:#e6db74">          echo $DBT_CI_BIGQUERY_CRED | base64 -d -i &gt; ./master_branch/test_profiles/cred.json;</span>          

      - <span style="color:#f92672">name</span>: <span style="color:#ae81ff">Install dbt &amp; packages</span>
        <span style="color:#f92672">shell</span>: <span style="color:#ae81ff">bash</span>
        <span style="color:#f92672">run</span>: |<span style="color:#e6db74">
</span><span style="color:#e6db74">          pip3 install dbt==0.21.0;
</span><span style="color:#e6db74">          dbt deps;</span>          

      - <span style="color:#f92672">name</span>: <span style="color:#ae81ff">Generate manifest.json from master</span>
        <span style="color:#f92672">shell</span>: <span style="color:#ae81ff">bash</span>
        <span style="color:#f92672">run</span>: <span style="color:#ae81ff">dbt compile --project-dir master_branch/ --profiles-dir master_branch/test_profiles/</span>

      <span style="color:#75715e"># Tell dbt to look up previous manifest file in master_branch/target </span>
      - <span style="color:#f92672">name</span>: <span style="color:#ae81ff">Build &amp; test models</span>
        <span style="color:#f92672">shell</span>: <span style="color:#ae81ff">bash</span>
        <span style="color:#f92672">run</span>: <span style="color:#ae81ff">dbt build --select state:modified --defer --state master_branch/target/</span>

      - <span style="color:#f92672">name</span>: <span style="color:#ae81ff">Archive compiled SQL</span>
        <span style="color:#f92672">if</span>: <span style="color:#ae81ff">${{ always() }}</span>
        <span style="color:#f92672">uses</span>: <span style="color:#ae81ff">actions/upload-artifact@v2</span>
        <span style="color:#f92672">with</span>: 
          <span style="color:#f92672">name</span>: <span style="color:#ae81ff">compiled_sql</span>
          <span style="color:#f92672">path</span>: <span style="color:#ae81ff">./target/compiled</span>

</code></pre></div><p>How this workflow is different from the previous one:</p>
<ul>
<li>First, we check out the files from our <code>master</code> branch to the <code>master_branch</code> folder within the current project</li>
<li>Then, we generate the manifest file from the master branch by running <code>dbt compile</code>, while specifying the project directory as <code>master_branch/</code>. The manifest file will be generated into <code>master_branch/target/</code> folder.
Note that it is necessary to also copy the credential file into the <code>master_branch</code> folder.</li>
<li>Finally, run <code>dbt build</code> while pointing to the <code>master_branch/target/</code> folder for state comparison</li>
</ul>
<p>As you can see, in the incremental workflow, only the new <code>test_model.sql</code> file is run, while the original full run workflow will run all the files.</p>
<p><img loading="lazy" src="/dbt-ci-with-github-actions/incr_run.png" alt=""  />
</p>
<p>So we have started to automate the boring stuff! However, this workflow has a drawback. Every time you push something new to an opened PR, the whole checkout and generate manifest steps will have to run again.</p>
<p>This may be OK if your project is small, but it may cost you more job run time if your project has hundreds of models.</p>
<p><img loading="lazy" src="/dbt-ci-with-github-actions/checkout_generate_runtime.png" alt=""  />
</p>
<p>We can certainly flex further and look for a way to reuse this manifest file.</p>
<h2 id="generate-manifest-file-when-merging-to-main-branch">Generate manifest file when merging to main branch<a hidden class="anchor" aria-hidden="true" href="#generate-manifest-file-when-merging-to-main-branch">#</a></h2>
<p>During model development, it is unlikely that the manifest file will change that much. We would want to reuse this manifest file, but GitHub Actions does not allow sharing files between different job runs.</p>
<p>We can work around this with workflow that update the manifest file when you merge a new PR. This is the workflow that do so:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#f92672">name</span>: <span style="color:#ae81ff">Update dbt project state</span>
<span style="color:#f92672">on</span>: 
  <span style="color:#f92672">pull_request</span>: 
    <span style="color:#f92672">types</span>: [<span style="color:#ae81ff">closed]</span>
  <span style="color:#f92672">workflow_dispatch</span>:
  
<span style="color:#f92672">jobs</span>:
  <span style="color:#f92672">update-project-state</span>:
    <span style="color:#f92672">if</span>: <span style="color:#ae81ff">github.event.pull_request.merged == true</span>
    <span style="color:#f92672">runs-on</span>: <span style="color:#ae81ff">ubuntu-latest</span>

    <span style="color:#f92672">env</span>: 
      <span style="color:#f92672">DBT_PROFILES_DIR</span>: <span style="color:#ae81ff">./test_profiles</span>
      <span style="color:#f92672">DBT_CI_BIGQUERY_PROJECT_ID</span>: <span style="color:#ae81ff">${{ secrets.DBT_CI_BIGQUERY_PROJECT_ID }}</span>

    <span style="color:#f92672">steps</span>:
      - <span style="color:#f92672">name</span>: <span style="color:#ae81ff">Checkout master</span>
        <span style="color:#f92672">uses</span>: <span style="color:#ae81ff">actions/checkout@v2</span>
        <span style="color:#f92672">with</span>:
          <span style="color:#f92672">ref</span>: <span style="color:#ae81ff">master</span>

      - <span style="color:#f92672">name</span>: <span style="color:#ae81ff">Read Bigquery credentials from secret</span>
        <span style="color:#f92672">shell</span>: <span style="color:#ae81ff">bash</span>
        <span style="color:#f92672">env</span>: 
          <span style="color:#f92672">DBT_CI_BIGQUERY_CRED</span>: <span style="color:#ae81ff">${{ secrets.DBT_CI_BIGQUERY_CRED }}</span>
        <span style="color:#f92672">run</span>: |<span style="color:#e6db74">
</span><span style="color:#e6db74">          mkdir -p ./test_profiles;
</span><span style="color:#e6db74">          echo $DBT_CI_BIGQUERY_CRED | base64 -d -i &gt; ./test_profiles/cred.json;</span>          

      - <span style="color:#f92672">name</span>: <span style="color:#ae81ff">Install dbt &amp; packages</span>
        <span style="color:#f92672">shell</span>: <span style="color:#ae81ff">bash</span>
        <span style="color:#f92672">run</span>: |<span style="color:#e6db74">
</span><span style="color:#e6db74">          pip3 install dbt==0.21.0;
</span><span style="color:#e6db74">          dbt deps;</span>          

      - <span style="color:#f92672">name</span>: <span style="color:#ae81ff">Generate manifest.json from master</span>
        <span style="color:#f92672">shell</span>: <span style="color:#ae81ff">bash</span>
        <span style="color:#f92672">run</span>: |<span style="color:#e6db74">
</span><span style="color:#e6db74">          dbt deps;
</span><span style="color:#e6db74">          dbt compile --no-version-check;
</span><span style="color:#e6db74">          mkdir -p ./current_state;
</span><span style="color:#e6db74">          cp ./target/manifest.json ./current_state/manifest.json;</span>          

      - <span style="color:#f92672">name</span>: <span style="color:#ae81ff">Commit new manifest.json file</span>
        <span style="color:#f92672">uses</span>: <span style="color:#ae81ff">EndBug/add-and-commit@v7.4.0</span>
        <span style="color:#f92672">with</span>:
          <span style="color:#f92672">add</span>: <span style="color:#e6db74">&#39;./current_state/manifest.json&#39;</span>
          <span style="color:#f92672">message</span>: <span style="color:#e6db74">&#39;manifest.json updated&#39;</span>
          <span style="color:#f92672">push</span>: <span style="color:#66d9ef">true</span>
          <span style="color:#f92672">branch</span>: <span style="color:#ae81ff">master</span>
</code></pre></div><p>This part:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#f92672">on</span>: 
  <span style="color:#f92672">pull_request</span>: 
    <span style="color:#f92672">types</span>: [<span style="color:#ae81ff">closed]</span>
  <span style="color:#f92672">workflow_dispatch</span>:

<span style="color:#f92672">jobs</span>:
  <span style="color:#f92672">update-project-state</span>:
  <span style="color:#f92672">if</span>: <span style="color:#ae81ff">github.event.pull_request.merged == true</span>
  <span style="color:#f92672">runs-on</span>: <span style="color:#ae81ff">ubuntu-latest</span>

</code></pre></div><p>specifies the types of events that will trigger this workflow.</p>
<ul>
<li>
<p><code>pull_request</code>: This workflow will run when you merge a PR to the master branch (defined with the <code>if</code> expression).</p>
</li>
<li>
<p><code>workflow_dispatch</code>: This means that you can also manually trigger this workflow from GitHub Action&rsquo;s UI.</p>
<p><img loading="lazy" src="/dbt-ci-with-github-actions/workflow-dispatch.png" alt=""  />
</p>
</li>
</ul>
<p>After this, in the main CI workflow you can remove the &ldquo;Checkout master&rdquo; and &ldquo;Generate manifest file from master&rdquo; steps. Since we now have the <code>manifest.json</code> file in the <code>current_state</code> folder, when running <code>dbt build</code> you need to point to this folder for state comparison.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">dbt build --select state:modified --defer --state current_state/
</code></pre></div><h1 id="bonus-run-jobs-inside-a-container">Bonus: Run jobs inside a container<a hidden class="anchor" aria-hidden="true" href="#bonus-run-jobs-inside-a-container">#</a></h1>
<p>In the workflows above, we have a step to install dbt into the runner:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">pip3 install dbt<span style="color:#f92672">==</span>0.21.0
</code></pre></div><p>You can also run dbt using dbt Labs' official Docker image so you won&rsquo;t need to worry about dependencies. Simply add the <code>container</code> and <code>image</code> properties to the job config:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#f92672">jobs</span>:
  <span style="color:#f92672">ci-incr-run</span>:
    <span style="color:#f92672">runs-on</span>: <span style="color:#ae81ff">ubuntu-latest</span>
    <span style="color:#f92672">container</span>: 
      <span style="color:#f92672">image</span>: <span style="color:#ae81ff">fishtownanalytics/dbt:0.21.0</span>
</code></pre></div><p>Now you can remove the <code>pip3 install dbt==0.21.0</code></p>
<h1 id="conclusion">Conclusion<a hidden class="anchor" aria-hidden="true" href="#conclusion">#</a></h1>
<p>Hope that this demonstration can help others who are trying to improve their dbt workflow. If you have any comments or questions, please create an issue in this repo: <a href="https://github.com/hoanghapham/dbt_ci_demo">https://github.com/hoanghapham/dbt_ci_demo</a>.</p>


  </div>

  <footer class="post-footer">
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2021 <a href="http://hoanghapham.github.io/">Ha&#39;s Learning Docs</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
